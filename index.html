<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AlgoCode Standings Analyzer</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 1.5rem;
      background: #f5f5f5;
      color: #222;
    }
    body.dark {
      background: #1c1c1c;
      color: #f5f5f5;
    }
    main {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    }
    body.dark main {
      background: rgba(32, 32, 32, 0.95);
      box-shadow: 0 10px 35px rgba(0, 0, 0, 0.4);
    }
    h1 {
      margin-top: 0;
      font-size: 1.8rem;
      text-align: center;
    }
    #status {
      margin: 1rem 0;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.05);
      border: 1px solid transparent;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }
    body.dark #status {
      background: rgba(255, 255, 255, 0.1);
    }
    #status.error {
      border-color: rgba(176, 0, 32, 0.4);
      color: #b00020;
      background: rgba(176, 0, 32, 0.08);
    }
    body.dark #status.error {
      color: #ffb3c1;
      background: rgba(176, 0, 32, 0.25);
      border-color: rgba(255, 179, 193, 0.5);
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      justify-content: space-between;
    }
    #controls label {
      display: flex;
      flex-direction: column;
      font-size: 0.9rem;
      gap: 0.35rem;
    }
    #controls select,
    #controls input[type="search"] {
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      font-size: 0.95rem;
      min-width: 160px;
      background: #fff;
      color: #222;
    }
    body.dark #controls select,
    body.dark #controls input[type="search"] {
      background: #2a2a2a;
      border-color: rgba(255, 255, 255, 0.25);
      color: #f5f5f5;
    }
    body.dark #controls select option {
      background: #2a2a2a;
      color: #f5f5f5;
    }
    #controls .button,
    #controls button {
      padding: 0.5rem 0.8rem;
      border-radius: 6px;
      border: none;
      font-size: 0.9rem;
      cursor: pointer;
      background: #0066cc;
      color: white;
      transition: background 0.2s ease;
    }
    #controls .button.secondary,
    #controls button.secondary {
      background: #555;
    }
    #controls .button:hover,
    #controls button:hover {
      background: #004999;
    }
    #controls .button.secondary:hover,
    #controls button.secondary:hover {
      background: #333;
    }
    #controls .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
    }
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }
    details.problem-filter {
      margin: 1.5rem 0 1rem;
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.03);
      overflow: hidden;
    }
    body.dark details.problem-filter {
      border-color: rgba(255, 255, 255, 0.16);
      background: rgba(255, 255, 255, 0.06);
    }
    details.problem-filter > summary {
      cursor: pointer;
      list-style: none;
      padding: 0.6rem 0.9rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      font-weight: 600;
    }
    details.problem-filter > summary::-webkit-details-marker {
      display: none;
    }
    details.problem-filter[open] > summary {
      border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    }
    body.dark details.problem-filter[open] > summary {
      border-bottom-color: rgba(255, 255, 255, 0.12);
    }
    #problem-filter-body {
      padding: 0.75rem 0.9rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    #problem-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }
    .contest-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 8px;
      padding: 0.65rem 0.75rem;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }
    body.dark .contest-group {
      background: rgba(0, 0, 0, 0.25);
      border-color: rgba(255, 255, 255, 0.08);
    }
    .contest-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }
    .contest-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 600;
    }
    .contest-toggle span {
      display: inline-flex;
      flex-direction: column;
      gap: 0.2rem;
    }
    .contest-count {
      font-size: 0.8rem;
      color: rgba(0, 0, 0, 0.6);
    }
    body.dark .contest-count {
      color: rgba(255, 255, 255, 0.6);
    }
    .contest-problem-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 0.4rem 0.6rem;
    }
    .contest-problem {
      display: flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.35rem 0.5rem;
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.04);
      cursor: pointer;
      transition: background 0.2s ease, opacity 0.2s ease;
    }
    .contest-problem:hover {
      background: rgba(0, 0, 0, 0.08);
    }
    body.dark .contest-problem {
      background: rgba(255, 255, 255, 0.1);
    }
    body.dark .contest-problem:hover {
      background: rgba(255, 255, 255, 0.16);
    }
    .contest-problem.is-deselected {
      opacity: 0.6;
    }
    .contest-problem .problem-code {
      font-weight: 600;
      font-size: 0.85rem;
    }
    .contest-problem .problem-title {
      font-size: 0.85rem;
      line-height: 1.2;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      font-size: 0.95rem;
    }
    thead {
      background: rgba(0, 0, 0, 0.08);
    }
    body.dark thead {
      background: rgba(255, 255, 255, 0.1);
    }
    th, td {
      padding: 0.6rem;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      text-align: left;
    }
    th.shrink,
    td.shrink {
      text-align: center;
      width: 3rem;
    }
    th.problem-column {
      min-width: 4.75rem;
    }
    .problem-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.2rem;
    }
    .problem-header .problem-code {
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    .problem-header .problem-title {
      font-size: 0.75rem;
      opacity: 0.75;
      line-height: 1.1;
      text-align: center;
    }
    .problem-header .problem-contest {
      font-size: 0.7rem;
      opacity: 0.6;
    }
    tr:nth-child(even) {
      background: rgba(0, 0, 0, 0.03);
    }
    body.dark tr:nth-child(even) {
      background: rgba(255, 255, 255, 0.05);
    }
    td.cell-solved {
      background: #e6f5ea;
      color: #0f5132;
      font-weight: 600;
    }
    body.dark td.cell-solved {
      background: rgba(46, 125, 50, 0.35);
      color: #c8e6c9;
    }
    td.cell-unsolved {
      background: #fff4e5;
      color: #8c2f00;
    }
    body.dark td.cell-unsolved {
      background: rgba(255, 183, 77, 0.18);
      color: #ffcc80;
    }
    td.cell-missing {
      background: rgba(0, 0, 0, 0.02);
      color: rgba(0, 0, 0, 0.55);
    }
    body.dark td.cell-missing {
      background: rgba(255, 255, 255, 0.08);
      color: rgba(255, 255, 255, 0.65);
    }
    .badge {
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 600;
      background: #e0f7ea;
      color: #1b5e20;
    }
    body.dark .badge {
      background: rgba(46, 125, 50, 0.35);
      color: #c8e6c9;
    }
    .muted {
      color: rgba(0, 0, 0, 0.6);
    }
    body.dark .muted {
      color: rgba(255, 255, 255, 0.6);
    }
    @media (max-width: 900px) {
      table {
        font-size: 0.85rem;
      }
      th, td {
        padding: 0.45rem;
      }
      #controls {
        flex-direction: column;
        align-items: stretch;
      }
      #controls label {
        width: 100%;
      }
      #controls .button,
      #controls button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <main>
    <h1>AlgoCode Standings Analyzer</h1>
    <section id="controls">
      <label>
        Group filter
        <select id="group-filter">
          <option value="__ALL__">All groups</option>
        </select>
      </label>
      <label>
        Name/Class filter
        <input id="search-filter" type="search" placeholder="Type to filter participants" aria-label="Filter participants" />
      </label>
      <label>
        Problem preset
        <select id="preset-selector">
          <option value="">Apply preset…</option>
        </select>
      </label>
      <div class="button-row">
        <button id="select-all" class="secondary" type="button">Select all problems</button>
        <button id="clear-selection" class="secondary" type="button">Clear selection</button>
        <button id="export" type="button">Export CSV</button>
        <a id="view-snapshot" class="button secondary" href="standings_data/bp_fall_2025.json" target="_blank" rel="noopener">Open snapshot</a>
      </div>
    </section>
    <details id="problem-filter-panel" class="problem-filter">
      <summary id="problem-filter-summary">
        Problem filters
        <span id="problem-filter-summary-count" class="muted"></span>
      </summary>
      <div id="problem-filter-body">
        <div id="problem-checkboxes" aria-label="Problem selection"></div>
      </div>
    </details>
    <div id="status" role="status">Loading standings…</div>
    <div class="table-wrapper">
      <table id="standings">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
  </main>
  <script>
    (function () {
      const API_URL = 'https://algocode.ru/standings_data/bp_fall_2025';
      const DATA_SOURCES = [
        {
          url: 'standings_data/bp_fall_2025.json',
          label: 'Cached snapshot',
          mode: 'same-origin'
        },
        {
          url: API_URL,
          label: 'Live standings',
          mode: 'cors'
        }
      ];
      const FALLBACK_SNAPSHOT = {
        legend: {
          problems: [
            { code: 'A', title: 'Intro Problem' },
            { code: 'B', title: 'Graphs Warmup' },
            { code: 'C', title: 'Dynamic Programming' }
          ]
        },
        rows: [
          {
            user: { name: 'Alice Example', group: 'B1', class: '10' },
            problems: [
              { result: 'AC' },
              { result: 'AC' },
              { result: 'WA' }
            ]
          },
          {
            user: { name: 'Bob Sample', group: 'B1', class: '10' },
            problems: [
              { result: 'WA' },
              { result: 'AC' },
              { result: 'AC' }
            ]
          },
          {
            user: { name: 'Charlie Demo', group: 'B2', class: '11' },
            problems: [
              { result: 'AC' },
              { result: 'WA' },
              { result: 'WA' }
            ]
          }
        ]
      };

      const RENDER_DEFER_MS = 5000;
      const FILTER_PRESET_URL = 'standings_data/problem_filter_presets.json';

      const presetState = {
        loaded: false,
        items: []
      };

      let pendingRenderTimeoutId = null;

      const state = {
        problems: [],
        participants: [],
        selectedProblems: new Set(),
        group: '__ALL__',
        search: '',
        dataSource: null,
        hasContestGroups: false,
        activePresetId: null,
        activePresetLabel: ''
      };

      let contestProblemContext = null;

      const elements = {
        status: document.getElementById('status'),
        groupFilter: document.getElementById('group-filter'),
        searchFilter: document.getElementById('search-filter'),
        presetSelector: document.getElementById('preset-selector'),
        problemContainer: document.getElementById('problem-checkboxes'),
        problemFilterPanel: document.getElementById('problem-filter-panel'),
        problemFilterSummaryCount: document.getElementById('problem-filter-summary-count'),
        tableHead: document.querySelector('#standings thead'),
        tableBody: document.querySelector('#standings tbody'),
        selectAll: document.getElementById('select-all'),
        clearSelection: document.getElementById('clear-selection'),
        exportButton: document.getElementById('export')
      };

      function setStatus(message, options = {}) {
        const { isError = false, detail } = options;
        elements.status.classList.toggle('error', Boolean(isError));
        elements.status.innerHTML = '';
        const summary = document.createElement('div');
        summary.textContent = message;
        elements.status.append(summary);
        if (detail) {
          const detailElement = document.createElement('div');
          detailElement.classList.add('muted');
          detailElement.textContent = detail;
          elements.status.append(detailElement);
        }
      }

      function scheduleRenderTable() {
        if (pendingRenderTimeoutId) {
          clearTimeout(pendingRenderTimeoutId);
        }
        pendingRenderTimeoutId = window.setTimeout(() => {
          pendingRenderTimeoutId = null;
          renderTable();
        }, RENDER_DEFER_MS);
      }

      function cancelScheduledRender() {
        if (pendingRenderTimeoutId) {
          clearTimeout(pendingRenderTimeoutId);
          pendingRenderTimeoutId = null;
        }
      }

      function clearActivePreset() {
        if (state.activePresetId || state.activePresetLabel) {
          state.activePresetId = null;
          state.activePresetLabel = '';
        }
      }

      function updateProblemFilterSummary() {
        if (!elements.problemFilterSummaryCount) {
          return;
        }
        const total = state.problems.length;
        if (!total) {
          elements.problemFilterSummaryCount.textContent = '• No problems loaded';
          return;
        }
        const selected = state.selectedProblems.size;
        let summaryText = `• ${selected}/${total} selected`;
        if (state.activePresetLabel) {
          summaryText += ` • Preset: ${state.activePresetLabel}`;
        }
        elements.problemFilterSummaryCount.textContent = summaryText;
      }

      function hasMultipleContestGroups(problems) {
        const groups = new Set();
        problems.forEach((problem) => {
          groups.add(problem.contestId ?? '__single__');
        });
        return groups.size > 1;
      }

      function groupProblemsForFilters() {
        if (!state.problems.length) {
          return [];
        }
        const map = new Map();
        state.problems.forEach((problem) => {
          const key = problem.contestId ?? '__standalone__';
          if (!map.has(key)) {
            const label = problem.displayContest ?? problem.contestLabel ?? problem.contestTitle;
            map.set(key, {
              id: key,
              title: label ?? 'All problems',
              order: problem.contestOrder ?? 0,
              problems: []
            });
          }
          const group = map.get(key);
          group.order = Math.min(group.order, problem.contestOrder ?? group.order ?? 0);
          group.problems.push(problem);
        });
        const groups = Array.from(map.values());
        groups.forEach((group) => {
          group.problems.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
        });
        groups.sort((a, b) => {
          if (a.order !== b.order) {
            return a.order - b.order;
          }
          return a.title.localeCompare(b.title, undefined, { sensitivity: 'base' });
        });
        return groups;
      }

      function normalizeIdList(value) {
        if (!value) {
          return [];
        }
        if (Array.isArray(value)) {
          return value
            .map((entry) => (entry == null ? '' : String(entry).trim()))
            .filter((entry) => entry.length);
        }
        if (typeof value === 'string') {
          return value
            .split(',')
            .map((entry) => entry.trim())
            .filter((entry) => entry.length);
        }
        return [];
      }

      function buildIdSet(values = [], { includeScopedSuffix = false } = {}) {
        const set = new Set();
        normalizeIdList(values).forEach((entry) => {
          set.add(entry);
          if (includeScopedSuffix && entry.includes('::')) {
            const suffix = entry.split('::').pop();
            if (suffix) {
              set.add(suffix);
            }
          }
        });
        return set;
      }

      function normalizePreset(raw, index) {
        if (!raw || typeof raw !== 'object') {
          return null;
        }
        const id = raw.id ? String(raw.id) : `preset-${index + 1}`;
        const label = raw.label ? String(raw.label) : `Preset ${index + 1}`;
        const description = typeof raw.description === 'string' ? raw.description : '';
        const selectRaw = typeof raw.select === 'string' ? raw.select.toLowerCase() : '';
        const select = selectRaw === 'all' || selectRaw === 'none' ? selectRaw : 'only';
        const include = raw.include && typeof raw.include === 'object' ? raw.include : null;
        const exclude = raw.exclude && typeof raw.exclude === 'object' ? raw.exclude : null;
        const contests = normalizeIdList(raw.contests ?? include?.contests ?? include?.contestIds);
        const problems = normalizeIdList(raw.problems ?? include?.problems ?? include?.problemIds);
        const excludeContests = normalizeIdList(raw.excludeContests ?? exclude?.contests ?? exclude?.contestIds);
        const excludeProblems = normalizeIdList(
          raw.excludeProblems ?? raw.excludedProblems ?? exclude?.problems ?? exclude?.problemIds
        );
        return {
          id,
          label,
          description,
          select,
          contests,
          problems,
          excludeContests,
          excludeProblems
        };
      }

      function renderPresetOptions() {
        if (!elements.presetSelector) {
          return;
        }
        const select = elements.presetSelector;
        const previousValue = select.value;
        select.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = presetState.items.length ? 'Apply preset…' : 'No presets available';
        if (!presetState.items.length) {
          placeholder.disabled = true;
        }
        select.append(placeholder);
        presetState.items.forEach((preset) => {
          const option = document.createElement('option');
          option.value = preset.id;
          option.textContent = preset.label;
          if (preset.description) {
            option.title = preset.description;
          }
          select.append(option);
        });
        if (presetState.items.length && previousValue && presetState.items.some((preset) => preset.id === previousValue)) {
          select.value = previousValue;
        } else {
          select.value = '';
        }
        select.disabled = !state.problems.length || !presetState.items.length;
      }

      async function loadFilterPresets() {
        if (presetState.loaded) {
          renderPresetOptions();
          return;
        }
        try {
          const response = await fetch(FILTER_PRESET_URL, {
            headers: { Accept: 'application/json, text/plain, */*' },
            cache: 'no-store'
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = await response.json();
          if (Array.isArray(payload)) {
            presetState.items = payload
              .map((item, index) => normalizePreset(item, index))
              .filter((item) => item !== null);
          }
        } catch (error) {
          console.warn('Failed to load problem filter presets:', error);
          presetState.items = [];
        } finally {
          presetState.loaded = true;
          renderPresetOptions();
        }
      }

      function applyPreset(preset) {
        if (!preset) {
          return;
        }
        const nextSelected = new Set();
        if (preset.select === 'all') {
          state.problems.forEach((problem) => {
            nextSelected.add(problem.id);
          });
        }
        const includeContestSet = buildIdSet(preset.contests);
        const includeProblemSet = buildIdSet(preset.problems);
        const excludeContestSet = buildIdSet(preset.excludeContests);
        const excludeProblemSet = buildIdSet(preset.excludeProblems);

        if (includeContestSet.size || includeProblemSet.size || preset.select === 'only' || preset.select === 'none') {
          if (preset.select !== 'all') {
            // start from empty selection when the preset should explicitly choose items
            nextSelected.clear();
          }
          state.problems.forEach((problem) => {
            const contestMatches = [
              problem.contestId,
              problem.contestLabel,
              problem.contestTitle,
              problem.displayContest
            ]
              .map((value) => (value == null ? '' : String(value)))
              .some((value) => value && includeContestSet.has(value));
            const aliases = [
              problem.id,
              problem.originalId,
              problem.short,
              problem.problemCode,
              problem.displayCode
            ];
            if (problem.contestId) {
              const contestPrefix = String(problem.contestId);
              aliases.push(`${contestPrefix}::${problem.short ?? problem.id}`);
              aliases.push(`${contestPrefix}::${problem.displayCode ?? problem.short ?? problem.id}`);
            }
            const problemMatches = aliases
              .map((value) => (value == null ? '' : String(value)))
              .some((value) => value && includeProblemSet.has(value));

            if (includeProblemSet.size) {
              if (problemMatches && (!includeContestSet.size || contestMatches)) {
                nextSelected.add(problem.id);
              }
            } else if (contestMatches) {
              nextSelected.add(problem.id);
            }
          });
        }

        if (excludeContestSet.size || excludeProblemSet.size) {
          state.problems.forEach((problem) => {
            const contestMatches = [
              problem.contestId,
              problem.contestLabel,
              problem.contestTitle,
              problem.displayContest
            ]
              .map((value) => (value == null ? '' : String(value)))
              .some((value) => value && excludeContestSet.has(value));
            if (contestMatches) {
              nextSelected.delete(problem.id);
              return;
            }
            const aliases = [
              problem.id,
              problem.originalId,
              problem.short,
              problem.problemCode,
              problem.displayCode
            ];
            if (problem.contestId) {
              const contestPrefix = String(problem.contestId);
              aliases.push(`${contestPrefix}::${problem.short ?? problem.id}`);
              aliases.push(`${contestPrefix}::${problem.displayCode ?? problem.short ?? problem.id}`);
            }
            const problemMatches = aliases
              .map((value) => (value == null ? '' : String(value)))
              .some((value) => value && excludeProblemSet.has(value));
            if (problemMatches) {
              nextSelected.delete(problem.id);
            }
          });
        }

        state.selectedProblems = nextSelected.size ? nextSelected : new Set();
        state.activePresetId = preset.id;
        state.activePresetLabel = preset.label;
        if (elements.problemFilterPanel && !elements.problemFilterPanel.open) {
          elements.problemFilterPanel.open = true;
        }
        renderProblemCheckboxes();
        cancelScheduledRender();
        renderTable();
      }

      async function loadStandings() {
        try {
          setStatus('Loading standings…');
          const errors = [];
          for (const source of DATA_SOURCES) {
            try {
              const data = await fetchStandingsFromSource(source);
              const normalized = normalizeStandings(data);
              state.problems = normalized.problems;
              state.participants = normalized.participants;
              state.selectedProblems = new Set(state.problems.map((problem) => problem.id));
              state.hasContestGroups = hasMultipleContestGroups(state.problems);
              state.dataSource = source;
              renderGroupFilter();
              renderProblemCheckboxes();
              renderTable();
              loadFilterPresets();
              const detailParts = [`Source: ${source.label}`];
              if (source.url) {
                detailParts.push(source.url);
              }
              setStatus(
                `Loaded ${state.participants.length} participants and ${state.problems.length} problems.`,
                { detail: detailParts.join(' • ') }
              );
              return;
            } catch (sourceError) {
              console.error(`Failed to fetch standings from ${source.label}:`, sourceError);
              let message = sourceError?.message || 'Unknown error';
              if (sourceError instanceof TypeError && message === 'Failed to fetch') {
                message = 'Failed to fetch (network error or CORS blocked)';
              }
              errors.push(`${source.label}: ${message}`);
            }
          }
          if (FALLBACK_SNAPSHOT) {
            const normalized = normalizeStandings(FALLBACK_SNAPSHOT);
            state.problems = normalized.problems;
            state.participants = normalized.participants;
            state.selectedProblems = new Set(state.problems.map((problem) => problem.id));
            state.hasContestGroups = hasMultipleContestGroups(state.problems);
            state.dataSource = { label: 'Bundled sample standings' };
            renderGroupFilter();
            renderProblemCheckboxes();
            renderTable();
            loadFilterPresets();
            const detailParts = ['Source: Bundled sample standings'];
            if (errors.length) {
              detailParts.push(`Previous errors: ${errors.join(' | ')}`);
            }
            setStatus(
              `Loaded ${state.participants.length} participants and ${state.problems.length} problems.`,
              { detail: detailParts.join(' • ') }
            );
            return;
          }
          const detailMessage = errors.length ? `Tried ${errors.length} source(s): ${errors.join(' | ')}` : undefined;
          throw new Error(detailMessage || 'Unable to load standings from any source.');
        } catch (error) {
          console.error(error);
          setStatus('Failed to load standings.', { isError: true, detail: error.message });
        }
      }

      async function fetchStandingsFromSource(source) {
        const response = await fetch(source.url, {
          headers: { 'Accept': 'application/json, text/plain, */*' },
          cache: 'no-store',
          mode: source.mode || 'cors'
        });
        const payloadText = await response.text();
        if (!response.ok) {
          throw new Error(`HTTP ${response.status} ${response.statusText || ''}`.trim());
        }
        if (!payloadText.trim()) {
          throw new Error('Response was empty.');
        }
        try {
          return JSON.parse(payloadText);
        } catch (parseError) {
          throw new Error('Response was not valid JSON.');
        }
      }

      function normalizeStandings(raw) {
        const problems = deriveProblems(raw);
        const participants = deriveParticipants(raw, problems);
        return { problems, participants };
      }

      function buildProblemsFromContests(contests) {
        const multiContest = contests.length > 1;
        const provisional = [];
        const locationLookup = new Map();
        contests.forEach((contest, contestIndex) => {
          const contestProblems = getContestProblemList(contest);
          if (!contestProblems.length) {
            return;
          }
          const contestId = contest?.id ?? contest?.slug ?? contest?.code ?? contest?.ejudge_id ?? `contest-${contestIndex + 1}`;
          const contestLabel = contest?.short ?? contest?.code ?? contest?.alias ?? contestId ?? `C${contestIndex + 1}`;
          const contestTitle = contest?.title ?? contest?.name ?? contestLabel ?? `Contest ${contestIndex + 1}`;
          const built = buildProblemsFromList(contestProblems, {
            contestId,
            contestLabel,
            contestTitle,
            contestOrder: contestIndex
          });
          built.forEach((problem, problemIndex) => {
            const baseId = multiContest ? `${contestId}::${problem.id}` : problem.id;
            const problemCode = problem.problemCode ?? problem.short ?? `P${problemIndex + 1}`;
            const problemTitle = problem.problemTitle ?? problem.title ?? `Problem ${problemIndex + 1}`;
            const tooltip = multiContest ? `${contestTitle} • ${problemTitle}` : problemTitle;
            provisional.push({
              ...problem,
              id: baseId,
              short: problemCode,
              title: problemTitle,
              problemCode,
              problemTitle,
              contestId,
              contestLabel,
              contestTitle,
              contestOrder: contestIndex,
              order: problem.order ?? problemIndex,
              displayCode: problemCode,
              displayContest: contestLabel ?? contestTitle,
              tooltip,
              originalId: problem.originalId ?? problem.id
            });
            locationLookup.set(baseId, { contestIndex, problemIndex });
          });
        });
        if (!provisional.length) {
          return { problems: [], lookup: new Map() };
        }
        const normalizedProblems = [];
        const normalizedLookup = new Map();
        const seenIds = new Set();
        provisional.forEach((problem) => {
          let id = problem.id || `p${normalizedProblems.length + 1}`;
          if (seenIds.has(id)) {
            let suffix = 1;
            let candidate = `${id}-${suffix}`;
            while (seenIds.has(candidate)) {
              suffix += 1;
              candidate = `${id}-${suffix}`;
            }
            id = candidate;
          }
          seenIds.add(id);
          const normalized = { ...problem, id };
          normalizedProblems.push(normalized);
          const location = locationLookup.get(problem.id) || locationLookup.get(problem.originalId) || locationLookup.get(id);
          if (location) {
            normalizedLookup.set(id, location);
          }
        });
        normalizedProblems.sort((a, b) => {
          if (a.contestOrder !== b.contestOrder) {
            return a.contestOrder - b.contestOrder;
          }
          return (a.order ?? 0) - (b.order ?? 0);
        });
        return { problems: normalizedProblems, lookup: normalizedLookup };
      }

      function getContestProblemList(contest) {
        const candidates = [
          contest?.problems,
          contest?.tasks,
          contest?.legend?.problems,
          contest?.legend?.tasks
        ];
        for (const candidate of candidates) {
          if (Array.isArray(candidate) && candidate.length) {
            return candidate;
          }
        }
        return [];
      }

      function deriveProblems(raw) {
        contestProblemContext = null;
        const candidates = [
          raw?.problems,
          raw?.tasks,
          raw?.columns,
          raw?.problem_columns,
          raw?.legend?.problems,
          raw?.legend?.tasks,
          raw?.header?.problems,
          raw?.header?.tasks
        ];
        for (const candidate of candidates) {
          if (Array.isArray(candidate) && candidate.length) {
            return buildProblemsFromList(candidate);
          }
        }
        for (const candidate of candidates) {
          if (candidate && typeof candidate === 'object') {
            const values = Object.values(candidate);
            if (Array.isArray(values) && values.length) {
              return buildProblemsFromList(values);
            }
          }
        }
        if (Array.isArray(raw?.contests) && raw.contests.length) {
          const context = buildProblemsFromContests(raw.contests);
          if (context.problems.length) {
            contestProblemContext = context;
            return context.problems;
          }
        }
        const inferred = inferProblemsFromRows(raw);
        return inferred.length ? inferred : [];
      }

      function deriveParticipants(raw, problems) {
        if (contestProblemContext && contestProblemContext.lookup && contestProblemContext.lookup.size) {
          const derived = deriveParticipantsFromContestStructure(raw, problems, contestProblemContext);
          if (derived) {
            return derived;
          }
        }
        const rows = findParticipantRows(raw);
        return rows.map((row, index) => normalizeParticipant(row, index, problems));
      }

      function deriveParticipantsFromContestStructure(raw, problems, context) {
        if (!Array.isArray(raw?.contests) || !raw.contests.length) {
          return null;
        }
        const userEntries = buildContestUserEntries(raw);
        if (!userEntries.length) {
          return null;
        }
        return userEntries.map((entry, index) => {
          const problemCells = problems.map((problem) => {
            const location = context.lookup.get(problem.id);
            if (!location) {
              return undefined;
            }
            const contest = raw.contests[location.contestIndex];
            if (!contest) {
              return undefined;
            }
            return extractContestCell(contest, entry, location, problem);
          });
          const solved = problemCells.reduce((sum, cell) => (detectSolved(cell) ? sum + 1 : sum), 0);
          const baseUser = entry.userData && typeof entry.userData === 'object' ? { ...entry.userData } : {};
          if (baseUser && typeof baseUser === 'object') {
            baseUser.id = baseUser.id ?? entry.primaryId;
          }
          const groupValue = [
            entry.userData?.group,
            entry.userData?.group_short,
            entry.userData?.groupShort,
            entry.userData?.division,
            entry.userData?.team_group
          ].find((value) => typeof value === 'string' && value.trim().length) ?? '';
          const classValue = [
            entry.userData?.class,
            entry.userData?.className,
            entry.userData?.grade,
            entry.userData?.class_short,
            entry.userData?.classShort
          ].find((value) => typeof value === 'string' && value.trim().length) ?? '';
          const syntheticRow = {
            id: entry.primaryId,
            user: baseUser,
            group: groupValue,
            class: classValue,
            problems: problemCells,
            solved
          };
          return normalizeParticipant(syntheticRow, index, problems);
        });
      }

      function buildContestUserEntries(raw) {
        const map = new Map();
        if (Array.isArray(raw?.users)) {
          raw.users.forEach((user, index) => {
            const candidates = gatherUserIdCandidates(user);
            const fallback = `participant-${index + 1}`;
            upsertContestUserEntry(map, candidates[0] ?? user?.id ?? fallback, user, candidates.length ? candidates : [fallback]);
          });
        } else if (raw?.users && typeof raw.users === 'object') {
          Object.entries(raw.users).forEach(([key, value], index) => {
            const candidates = gatherUserIdCandidates(value);
            const fallback = key ?? `participant-${index + 1}`;
            const ids = candidates.length ? candidates : [];
            if (fallback != null) {
              ids.unshift(String(fallback));
            }
            upsertContestUserEntry(map, fallback, value, ids);
          });
        }
        if (Array.isArray(raw?.contests)) {
          raw.contests.forEach((contest) => {
            const collection = getContestUserCollection(contest);
            if (!collection) {
              return;
            }
            if (Array.isArray(collection)) {
              collection.forEach((entry, index) => {
                const userData = entry?.user && typeof entry.user === 'object' ? entry.user : entry;
                const candidates = gatherUserIdCandidates(entry);
                const fallback = userData?.id ?? entry?.id ?? `contest-user-${index + 1}`;
                const ids = candidates.length ? candidates : [];
                if (userData?.id != null) {
                  ids.unshift(String(userData.id));
                }
                if (entry?.id != null) {
                  ids.unshift(String(entry.id));
                }
                upsertContestUserEntry(map, fallback, userData, ids);
              });
            } else if (typeof collection === 'object') {
              Object.entries(collection).forEach(([key, value]) => {
                const userData = value?.user && typeof value.user === 'object' ? value.user : value;
                const candidates = gatherUserIdCandidates(userData);
                const ids = candidates.length ? candidates : [];
                if (key != null) {
                  ids.unshift(String(key));
                }
                upsertContestUserEntry(map, key, userData, ids);
              });
            }
          });
        }
        return Array.from(map.values());
      }

      function upsertContestUserEntry(map, primaryId, userData, idCandidates = []) {
        const normalizedCandidates = [];
        idCandidates.forEach((candidate) => {
          if (candidate == null) {
            return;
          }
          const normalized = String(candidate);
          if (!normalized) {
            return;
          }
          if (!normalizedCandidates.includes(normalized)) {
            normalizedCandidates.push(normalized);
          }
        });
        if (primaryId != null) {
          const normalized = String(primaryId);
          if (normalized && !normalizedCandidates.includes(normalized)) {
            normalizedCandidates.unshift(normalized);
          }
        }
        if (!normalizedCandidates.length) {
          return;
        }
        const key = normalizedCandidates[0];
        const existing = map.get(key);
        let cleanedUser;
        if (userData && typeof userData === 'object' && !Array.isArray(userData)) {
          cleanedUser = { ...userData };
        } else if (typeof userData === 'string') {
          cleanedUser = { name: userData };
        } else {
          cleanedUser = {};
        }
        if (!cleanedUser.name && key) {
          cleanedUser.name = cleanedUser.name ?? `Participant ${key}`;
        }
        if (existing) {
          existing.userData = mergeUserData(existing.userData, cleanedUser);
          normalizedCandidates.forEach((candidate) => {
            if (!existing.idCandidates.includes(candidate)) {
              existing.idCandidates.push(candidate);
            }
          });
          return;
        }
        map.set(key, {
          primaryId: key,
          userData: cleanedUser,
          idCandidates: normalizedCandidates
        });
      }

      function mergeUserData(base, incoming) {
        if (!incoming || typeof incoming !== 'object') {
          return base;
        }
        if (!base || typeof base !== 'object') {
          return { ...incoming };
        }
        const merged = { ...base };
        Object.entries(incoming).forEach(([key, value]) => {
          if (value == null || value === '') {
            return;
          }
          if (key === 'name' && typeof value === 'string') {
            if (typeof merged.name !== 'string' || !merged.name.trim().length || value.trim().length > merged.name.trim().length) {
              merged.name = value;
            }
            return;
          }
          if (merged[key] == null || merged[key] === '') {
            merged[key] = value;
          }
        });
        return merged;
      }

      function gatherUserIdCandidates(user) {
        if (!user || typeof user !== 'object') {
          return [];
        }
        const candidates = [
          user.id,
          user.user_id,
          user.userId,
          user.participant_id,
          user.participantId,
          user.contestant_id,
          user.contestantId,
          user.account_id,
          user.accountId,
          user.ejudge_id,
          user.ej_id,
          user.login,
          user.username,
          user.external_id,
          user.externalId,
          user.code
        ];
        const normalized = [];
        candidates.forEach((candidate) => {
          if (candidate == null) {
            return;
          }
          const value = String(candidate);
          if (!value) {
            return;
          }
          if (!normalized.includes(value)) {
            normalized.push(value);
          }
        });
        return normalized;
      }

      function getContestUserCollection(contest) {
        const candidates = [
          contest?.users,
          contest?.participants,
          contest?.rows,
          contest?.standings,
          contest?.entries,
          contest?.data,
          contest?.result
        ];
        for (const candidate of candidates) {
          if (candidate != null) {
            return candidate;
          }
        }
        return undefined;
      }

      function findContestUserEntry(collection, idCandidates) {
        if (!collection) {
          return undefined;
        }
        if (Array.isArray(collection)) {
          return collection.find((entry) => {
            if (!entry || typeof entry !== 'object') {
              return false;
            }
            const entryCandidates = new Set([
              ...gatherUserIdCandidates(entry),
              ...(entry.user && typeof entry.user === 'object' ? gatherUserIdCandidates(entry.user) : [])
            ]);
            return idCandidates.some((candidate) => entryCandidates.has(candidate));
          });
        }
        if (typeof collection === 'object') {
          for (const candidate of idCandidates) {
            if (candidate == null) {
              continue;
            }
            const key = String(candidate);
            if (Object.prototype.hasOwnProperty.call(collection, key)) {
              return collection[key];
            }
          }
        }
        return undefined;
      }

      function extractContestCell(contest, entry, location, problem) {
        const collection = getContestUserCollection(contest);
        if (!collection) {
          return undefined;
        }
        const contestRow = findContestUserEntry(collection, entry.idCandidates);
        if (!contestRow) {
          return undefined;
        }
        if (Array.isArray(contestRow)) {
          return contestRow[location.problemIndex];
        }
        const cells = getProblemCells(contestRow);
        if (Array.isArray(cells)) {
          return cells[location.problemIndex];
        }
        if (cells && typeof cells === 'object') {
          const keysToTry = [
            problem.id,
            problem.short,
            problem.title,
            location.problemIndex,
            `p${location.problemIndex + 1}`
          ];
          for (const key of keysToTry) {
            if (key == null) {
              continue;
            }
            if (Object.prototype.hasOwnProperty.call(cells, key)) {
              return cells[key];
            }
            const stringKey = String(key);
            if (Object.prototype.hasOwnProperty.call(cells, stringKey)) {
              return cells[stringKey];
            }
          }
        }
        return undefined;
      }

      function buildProblemsFromList(list, options = {}) {
        const seenIds = new Set();
        return list.map((item, index) => {
          const asObject = typeof item === 'object' && item !== null;
          const idCandidate = asObject
            ? (item.id ?? item.problem ?? item.code ?? item.short ?? item.letter ?? item.alias ?? item.name ?? item.value)
            : item;
          let normalizedId = idCandidate ? String(idCandidate) : `p${index + 1}`;
          if (seenIds.has(normalizedId)) {
            let suffix = 1;
            let candidateId = `${normalizedId}-${suffix}`;
            while (seenIds.has(candidateId)) {
              suffix += 1;
              candidateId = `${normalizedId}-${suffix}`;
            }
            normalizedId = candidateId;
          }
          seenIds.add(normalizedId);
          const shortLabel = asObject
            ? (item.short ?? item.letter ?? item.code ?? item.alias ?? item.id ?? item.problem ?? item.name)
            : item;
          const title = asObject
            ? (item.title ?? item.name ?? item.problem ?? item.description ?? item.text ?? item.label ?? shortLabel ?? normalizedId)
            : item;
          const problemCode = shortLabel ? String(shortLabel) : `P${index + 1}`;
          const problemTitle = title ? String(title) : `Problem ${index + 1}`;
          return {
            id: normalizedId,
            originalId: normalizedId,
            short: problemCode,
            title: problemTitle,
            problemCode,
            problemTitle,
            contestId: options.contestId ?? options.defaultContestId ?? null,
            contestLabel: options.contestLabel ?? null,
            contestTitle: options.contestTitle ?? null,
            contestOrder: options.contestOrder ?? 0,
            order: (options.offset ?? 0) + index,
            displayCode: problemCode,
            displayContest: options.contestLabel ?? options.contestTitle ?? null,
            tooltip: problemTitle
          };
        });
      }

      function findParticipantRows(raw) {
        const candidateArrays = [
          raw?.rows,
          raw?.participants,
          raw?.standings,
          raw?.data,
          raw?.table,
          raw?.users,
          raw?.result,
          raw?.entries,
          Array.isArray(raw) ? raw : undefined
        ];
        for (const entry of candidateArrays) {
          if (Array.isArray(entry) && entry.length) {
            return entry;
          }
        }
        return [];
      }

      function getProblemCells(row) {
        const candidates = [
          row?.problems,
          row?.tasks,
          row?.results,
          row?.scores,
          row?.columns,
          row?.solutions,
          row?.task_results,
          row?.problem_results,
          row?.taskResults,
          row?.problemResults,
          row?.tasks_columns,
          row?.problems_columns
        ];
        for (const candidate of candidates) {
          if (Array.isArray(candidate) && candidate.length) {
            return candidate;
          }
        }
        for (const candidate of candidates) {
          if (candidate != null) {
            return candidate;
          }
        }
        return [];
      }

      function inferProblemsFromRows(raw) {
        const rows = findParticipantRows(raw);
        for (const row of rows) {
          const cells = getProblemCells(row);
          if (Array.isArray(cells) && cells.length) {
            return buildProblemsFromList(Array.from({ length: cells.length }));
          }
          if (cells && typeof cells === 'object') {
            const entries = Object.entries(cells);
            if (entries.length) {
              const list = entries.map(([key, value]) => {
                if (value && typeof value === 'object') {
                  return {
                    id: key,
                    short: value.short ?? value.letter ?? value.code ?? value.alias ?? key,
                    title: value.title ?? value.name ?? value.problem ?? value.description ?? key
                  };
                }
                return {
                  id: key,
                  short: key,
                  title: String(value ?? key)
                };
              });
              return buildProblemsFromList(list);
            }
          }
        }
        return [];
      }

      function normalizeParticipant(row, index, problems) {
        const base = row?.user ?? row?.participant ?? row?.party ?? row?.team ?? row?.contestant ?? row?.student ?? row;
        const members = Array.isArray(base?.members) ? base.members : Array.isArray(row?.members) ? row.members : undefined;
        const composedName = members ? members.map((member) => member?.name ?? member?.title ?? '').filter(Boolean).join(', ') : undefined;
        const name = [
          base?.name,
          base?.title,
          base?.displayName,
          composedName,
          row?.name,
          row?.title,
          `Participant ${index + 1}`
        ].find((value) => typeof value === 'string' && value.trim().length) ?? `Participant ${index + 1}`;
        const groupValue = [row?.group, base?.group, row?.division, base?.division, row?.team_group, base?.team_group]
          .find((value) => typeof value === 'string' && value.trim().length) ?? '';
        const classValue = [row?.class, row?.className, base?.class, base?.className, row?.grade, base?.grade]
          .find((value) => typeof value === 'string' && value.trim().length) ?? '';
        const problemCells = getProblemCells(row);
        const perProblem = {};
        problems.forEach((problem, problemIndex) => {
          let cell;
          if (Array.isArray(problemCells)) {
            cell = problemCells[problemIndex];
          } else if (problemCells && typeof problemCells === 'object') {
            const keysToTry = [problem.id, problem.short, problem.title, problemIndex, `p${problemIndex + 1}`];
            for (const key of keysToTry) {
              if (key !== undefined && key !== null && Object.prototype.hasOwnProperty.call(problemCells, key)) {
                cell = problemCells[key];
                break;
              }
            }
          }
          perProblem[problem.id] = {
            solved: detectSolved(cell),
            display: formatCell(cell)
          };
        });
        const fallbackSolved = typeof row?.solved === 'number' ? row.solved : (typeof row?.score === 'number' ? row.score : undefined);
        return {
          id: row?.id ?? base?.id ?? index,
          name: String(name),
          group: groupValue,
          className: classValue,
          problems: perProblem,
          fallbackSolved: fallbackSolved
        };
      }

      function normalizeStatusText(value) {
        if (value == null) return '';
        return String(value)
          .trim()
          .toLowerCase()
          .replace(/[_-]+/g, ' ');
      }

      function extractStatusString(cell) {
        const statusFields = [
          'display',
          'result',
          'status_verbose',
          'statusText',
          'status',
          'verdictText',
          'verdict',
          'bestVerdict',
          'best_verdict',
          'bestResult',
          'best_result',
          'maxResult',
          'max_result',
          'outcome',
          'text',
          'label'
        ];
        for (const key of statusFields) {
          if (Object.prototype.hasOwnProperty.call(cell, key)) {
            const text = String(cell[key]).trim();
            if (text) {
              return text;
            }
          }
        }
        return '';
      }

      function statusImpliesSolved(statusText) {
        const normalized = normalizeStatusText(statusText);
        if (!normalized) return false;
        const positiveKeywords = [
          'ac',
          'ok',
          'accepted',
          'solved',
          'yes',
          'true',
          '+',
          '✔',
          '✓',
          'passed',
          'complete',
          'success',
          'done'
        ];
        if (positiveKeywords.includes(normalized)) {
          return true;
        }
        return [
          'ac',
          'ok',
          'accept',
          'solve',
          'pass',
          'success',
          'done',
          'complete'
        ].some((token) => normalized.includes(token));
      }

      function detectSolved(cell) {
        if (cell == null) {
          return false;
        }
        if (typeof cell === 'boolean') {
          return cell;
        }
        if (typeof cell === 'number') {
          return cell > 0;
        }
        if (typeof cell === 'string') {
          const trimmed = cell.trim();
          if (!trimmed) {
            return false;
          }
          const numeric = Number(trimmed);
          if (!Number.isNaN(numeric)) {
            return numeric > 0;
          }
          return statusImpliesSolved(trimmed);
        }
        if (typeof cell === 'object') {
          if (Object.prototype.hasOwnProperty.call(cell, 'solved')) {
            return Boolean(cell.solved);
          }
          if (Object.prototype.hasOwnProperty.call(cell, 'isSolved')) {
            return Boolean(cell.isSolved);
          }
          if (Object.prototype.hasOwnProperty.call(cell, 'ok')) {
            return Boolean(cell.ok);
          }
          const numericCandidates = [
            cell.score,
            cell.points,
            cell.value,
            cell.max_result,
            cell.maxResult,
            cell.best_score,
            cell.bestScore
          ];
          for (const candidate of numericCandidates) {
            if (candidate != null && !Number.isNaN(Number(candidate))) {
              return Number(candidate) > 0;
            }
          }
          const statusText = extractStatusString(cell);
          if (statusText) {
            return statusImpliesSolved(statusText);
          }
        }
        return false;
      }

      function formatCell(cell) {
        if (cell == null) {
          return '';
        }
        if (typeof cell === 'object') {
          const statusText = extractStatusString(cell);
          const attempts = cell.attempts ?? cell.tries;
          const penalty = cell.penalty ?? cell.time ?? cell.minutes;
          const numericScore =
            cell.score ?? cell.points ?? cell.value ?? cell.max_result ?? cell.maxResult ?? cell.best_score ?? cell.bestScore;
          const parts = [];
          if (statusText) {
            parts.push(statusText);
          }
          if (attempts != null) {
            parts.push(`${attempts} tries`);
          }
          if (penalty != null) {
            parts.push(`${penalty}`);
          }
          if (parts.length) {
            return parts.join(' · ');
          }
          if (numericScore != null) {
            return String(numericScore);
          }
          if (Object.prototype.hasOwnProperty.call(cell, 'ok')) {
            return cell.ok ? '✓' : '✗';
          }
          return JSON.stringify(cell);
        }
        return String(cell);
      }

      function renderGroupFilter() {
        const groups = new Map();
        groups.set('__ALL__', { label: 'All groups', value: '__ALL__' });
        state.participants.forEach((participant) => {
          const rawValue = participant.group?.trim() ?? '';
          const key = rawValue || '__EMPTY__';
          if (!groups.has(key)) {
            groups.set(key, {
              label: rawValue || '—',
              value: key
            });
          }
        });
        const options = Array.from(groups.values()).sort((a, b) => {
          if (a.value === '__ALL__') return -1;
          if (b.value === '__ALL__') return 1;
          return a.label.localeCompare(b.label, undefined, { sensitivity: 'base' });
        });
        elements.groupFilter.innerHTML = '';
        options.forEach((option) => {
          const opt = document.createElement('option');
          opt.value = option.value;
          opt.textContent = option.label;
          if (option.value === state.group) {
            opt.selected = true;
          }
          elements.groupFilter.append(opt);
        });
      }

      function renderProblemCheckboxes() {
        if (!elements.problemContainer) {
          return;
        }
        elements.problemContainer.innerHTML = '';
        if (elements.problemFilterPanel) {
          elements.problemFilterPanel.classList.toggle('is-empty', !state.problems.length);
        }
        if (elements.presetSelector) {
          elements.presetSelector.disabled = !state.problems.length || !presetState.items.length;
        }
        if (!state.problems.length) {
          const span = document.createElement('span');
          span.textContent = 'No problems found in the standings.';
          elements.problemContainer.append(span);
          updateProblemFilterSummary();
          return;
        }
        const groups = groupProblemsForFilters();
        groups.forEach((group) => {
          const groupElement = document.createElement('div');
          groupElement.classList.add('contest-group');

          const header = document.createElement('div');
          header.classList.add('contest-header');

          const groupLabel = document.createElement('label');
          groupLabel.classList.add('contest-toggle');

          const groupCheckbox = document.createElement('input');
          groupCheckbox.type = 'checkbox';
          groupCheckbox.value = group.id;

          const labelText = document.createElement('span');
          labelText.textContent = group.title;

          groupLabel.append(groupCheckbox, labelText);
          header.append(groupLabel);

          const countDisplay = document.createElement('span');
          countDisplay.classList.add('contest-count');
          header.append(countDisplay);

          const problemList = document.createElement('div');
          problemList.classList.add('contest-problem-list');

          const problemControls = [];

          const computeSelectedCount = () =>
            group.problems.reduce((sum, problem) => (state.selectedProblems.has(problem.id) ? sum + 1 : sum), 0);

          const updateGroupState = () => {
            const selectedCount = computeSelectedCount();
            countDisplay.textContent = `${selectedCount}/${group.problems.length} selected`;
            if (selectedCount === group.problems.length) {
              groupCheckbox.checked = true;
              groupCheckbox.indeterminate = false;
            } else if (selectedCount === 0) {
              groupCheckbox.checked = false;
              groupCheckbox.indeterminate = false;
            } else {
              groupCheckbox.checked = false;
              groupCheckbox.indeterminate = true;
            }
          };

          group.problems.forEach((problem) => {
            const problemLabel = document.createElement('label');
            problemLabel.classList.add('contest-problem');
            problemLabel.dataset.problemId = problem.id;
            problemLabel.title = problem.tooltip ?? problem.problemTitle ?? problem.title ?? problem.displayCode;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = problem.id;
            checkbox.checked = state.selectedProblems.has(problem.id);

            const codeSpan = document.createElement('span');
            codeSpan.classList.add('problem-code');
            codeSpan.textContent = problem.displayCode ?? problem.short ?? problem.id;

            const titleSpan = document.createElement('span');
            titleSpan.classList.add('problem-title');
            titleSpan.textContent = problem.problemTitle ?? problem.title ?? problem.displayCode ?? 'Problem';

            problemLabel.append(checkbox, codeSpan, titleSpan);
            problemLabel.classList.toggle('is-deselected', !checkbox.checked);

            checkbox.addEventListener('change', (event) => {
              const { checked } = event.target;
              if (checked) {
                state.selectedProblems.add(problem.id);
              } else {
                state.selectedProblems.delete(problem.id);
              }
              problemLabel.classList.toggle('is-deselected', !checked);
              clearActivePreset();
              updateGroupState();
              updateProblemFilterSummary();
              scheduleRenderTable();
            });

            problemControls.push({ checkbox, label: problemLabel });
            problemList.append(problemLabel);
          });

          groupCheckbox.addEventListener('change', (event) => {
            const { checked } = event.target;
            group.problems.forEach((problem) => {
              if (checked) {
                state.selectedProblems.add(problem.id);
              } else {
                state.selectedProblems.delete(problem.id);
              }
            });
            problemControls.forEach(({ checkbox, label }) => {
              checkbox.checked = checked;
              label.classList.toggle('is-deselected', !checked);
            });
            clearActivePreset();
            updateGroupState();
            updateProblemFilterSummary();
            scheduleRenderTable();
          });

          updateGroupState();

          groupElement.append(header, problemList);
          elements.problemContainer.append(groupElement);
        });

        updateProblemFilterSummary();
      }

      function computeSolvedCount(participant) {
        let solved = 0;
        const selectedProblems = state.selectedProblems.size ? state.selectedProblems : new Set(state.problems.map((problem) => problem.id));
        selectedProblems.forEach((problemId) => {
          if (participant.problems[problemId]?.solved) {
            solved += 1;
          }
        });
        if (!solved && selectedProblems.size === state.problems.length && typeof participant.fallbackSolved === 'number') {
          solved = participant.fallbackSolved;
        }
        return solved;
      }

      function filterParticipants() {
        return state.participants.filter((participant) => {
          const matchesGroup = state.group === '__ALL__'
            ? true
            : state.group === '__EMPTY__'
              ? (participant.group?.trim() ?? '') === ''
              : (participant.group?.trim() ?? '') === state.group;
          if (!matchesGroup) {
            return false;
          }
          if (!state.search) {
            return true;
          }
          const haystack = `${participant.name} ${participant.group ?? ''} ${participant.className ?? ''}`.toLowerCase();
          return haystack.includes(state.search);
        });
      }

      function getVisibleProblems() {
        if (!state.selectedProblems.size) {
          return [];
        }
        return state.problems.filter((problem) => state.selectedProblems.has(problem.id));
      }

      function renderTable() {
        const visibleProblems = getVisibleProblems();
        const hasMultipleContestGroups = state.hasContestGroups;
        const filtered = filterParticipants().map((participant) => ({
          ...participant,
          solvedCount: computeSolvedCount(participant)
        }));
        filtered.sort((a, b) => {
          if (b.solvedCount !== a.solvedCount) {
            return b.solvedCount - a.solvedCount;
          }
          return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
        });

        elements.tableHead.innerHTML = '';
        const headerRow = document.createElement('tr');
        [
          { text: '#', className: 'shrink' },
          { text: 'Participant' },
          { text: 'Group' },
          { text: 'Class' },
          { text: 'Solved', className: 'shrink' }
        ].forEach((column) => {
          const th = document.createElement('th');
          th.textContent = column.text;
          if (column.className) {
            th.classList.add(column.className);
          }
          headerRow.append(th);
        });
        visibleProblems.forEach((problem) => {
          const th = document.createElement('th');
          th.classList.add('shrink', 'problem-column');
          th.title = problem.tooltip ?? problem.problemTitle ?? problem.title ?? problem.displayCode ?? '';
          const container = document.createElement('div');
          container.classList.add('problem-header');

          const codeSpan = document.createElement('span');
          codeSpan.classList.add('problem-code');
          codeSpan.textContent = problem.displayCode ?? problem.short ?? problem.id;
          container.append(codeSpan);

          const titleText = problem.problemTitle ?? problem.title;
          if (titleText && titleText !== codeSpan.textContent) {
            const titleSpan = document.createElement('span');
            titleSpan.classList.add('problem-title');
            titleSpan.textContent = titleText;
            container.append(titleSpan);
          }

          const contestLabel = problem.displayContest ?? problem.contestLabel ?? problem.contestTitle;
          if (hasMultipleContestGroups && contestLabel && contestLabel !== titleText) {
            const contestSpan = document.createElement('span');
            contestSpan.classList.add('problem-contest');
            contestSpan.textContent = contestLabel;
            container.append(contestSpan);
          }

          th.append(container);
          headerRow.append(th);
        });
        elements.tableHead.append(headerRow);

        elements.tableBody.innerHTML = '';
        if (!filtered.length) {
          const row = document.createElement('tr');
          const cell = document.createElement('td');
          cell.colSpan = 5 + visibleProblems.length;
          cell.textContent = 'No participants match the current filters.';
          row.append(cell);
          elements.tableBody.append(row);
          return;
        }

        filtered.forEach((participant, index) => {
          const row = document.createElement('tr');
          const rankCell = document.createElement('td');
          rankCell.textContent = String(index + 1);
          rankCell.classList.add('shrink');
          row.append(rankCell);

          const nameCell = document.createElement('td');
          nameCell.textContent = participant.name;
          row.append(nameCell);

          const groupCell = document.createElement('td');
          groupCell.textContent = participant.group || '—';
          row.append(groupCell);

          const classCell = document.createElement('td');
          classCell.textContent = participant.className || '—';
          row.append(classCell);

          const solvedCell = document.createElement('td');
          solvedCell.classList.add('shrink');
          solvedCell.innerHTML = `<span class="badge">${participant.solvedCount}</span>`;
          row.append(solvedCell);

          visibleProblems.forEach((problem) => {
            const cell = document.createElement('td');
            cell.classList.add('shrink');
            const entry = participant.problems[problem.id];
            if (!entry) {
              cell.classList.add('cell-missing');
              cell.textContent = '—';
              if (problem.tooltip) {
                cell.title = problem.tooltip;
              }
            } else if (entry.solved) {
              cell.classList.add('cell-solved');
              cell.textContent = '✓';
              if (entry.display && entry.display !== '✓') {
                cell.title = entry.display;
              }
            } else {
              cell.classList.add('cell-unsolved');
              cell.textContent = '—';
              if (entry.display && entry.display !== '—') {
                cell.title = entry.display;
              }
            }
            row.append(cell);
          });
          elements.tableBody.append(row);
        });
      }

      function exportCsv() {
        const visibleProblems = getVisibleProblems();
        const filtered = filterParticipants().map((participant) => ({
          ...participant,
          solvedCount: computeSolvedCount(participant)
        })).sort((a, b) => {
          if (b.solvedCount !== a.solvedCount) {
            return b.solvedCount - a.solvedCount;
          }
          return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
        });
        const header = ['Rank', 'Participant', 'Group', 'Class', 'Solved'];
        visibleProblems.forEach((problem) => header.push(problem.short));
        const rows = [header];
        filtered.forEach((participant, index) => {
          const row = [
            index + 1,
            escapeCsv(participant.name),
            escapeCsv(participant.group || ''),
            escapeCsv(participant.className || ''),
            participant.solvedCount
          ];
          visibleProblems.forEach((problem) => {
            const entry = participant.problems[problem.id];
            row.push(escapeCsv(entry?.display ?? (entry?.solved ? 'Solved' : '')));
          });
          rows.push(row);
        });
        const csvContent = rows.map((row) => row.join(',')).join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'algocode-standings.csv';
        link.style.display = 'none';
        document.body.append(link);
        link.click();
        setTimeout(() => {
          URL.revokeObjectURL(link.href);
          link.remove();
        }, 0);
      }

      function escapeCsv(value) {
        const stringValue = String(value ?? '');
        if (/[",\n]/.test(stringValue)) {
          return `"${stringValue.replace(/"/g, '""')}"`;
        }
        return stringValue;
      }

      elements.groupFilter.addEventListener('change', (event) => {
        state.group = event.target.value;
        renderTable();
      });

      elements.searchFilter.addEventListener('input', (event) => {
        state.search = event.target.value.trim().toLowerCase();
        cancelScheduledRender();
        renderTable();
      });

      if (elements.presetSelector) {
        elements.presetSelector.addEventListener('change', (event) => {
          const presetId = event.target.value;
          if (!presetId) {
            return;
          }
          const preset = presetState.items.find((item) => item.id === presetId);
          if (preset) {
            applyPreset(preset);
            updateProblemFilterSummary();
          }
          event.target.value = '';
        });
      }

      elements.selectAll.addEventListener('click', () => {
        state.selectedProblems = new Set(state.problems.map((problem) => problem.id));
        clearActivePreset();
        renderProblemCheckboxes();
        cancelScheduledRender();
        renderTable();
      });

      elements.clearSelection.addEventListener('click', () => {
        state.selectedProblems.clear();
        clearActivePreset();
        renderProblemCheckboxes();
        cancelScheduledRender();
        renderTable();
      });

      elements.exportButton.addEventListener('click', () => {
        exportCsv();
      });

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }

      updateProblemFilterSummary();
      loadStandings();
    })();
  </script>
</body>
</html>
